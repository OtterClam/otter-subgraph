// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class KickReward extends ethereum.Event {
  get params(): KickReward__Params {
    return new KickReward__Params(this);
  }
}

export class KickReward__Params {
  _event: KickReward;

  constructor(event: KickReward) {
    this._event = event;
  }

  get _user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _kicked(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _reward(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class OperatorStatus extends ethereum.Event {
  get params(): OperatorStatus__Params {
    return new OperatorStatus__Params(this);
  }
}

export class OperatorStatus__Params {
  _event: OperatorStatus;

  constructor(event: OperatorStatus) {
    this._event = event;
  }

  get candidate(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get status(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class Recovered extends ethereum.Event {
  get params(): Recovered__Params {
    return new Recovered__Params(this);
  }
}

export class Recovered__Params {
  _event: Recovered;

  constructor(event: Recovered) {
    this._event = event;
  }

  get _token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class RewardAdded extends ethereum.Event {
  get params(): RewardAdded__Params {
    return new RewardAdded__Params(this);
  }
}

export class RewardAdded__Params {
  _event: RewardAdded;

  constructor(event: RewardAdded) {
    this._event = event;
  }

  get _token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _reward(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class RewardPaid extends ethereum.Event {
  get params(): RewardPaid__Params {
    return new RewardPaid__Params(this);
  }
}

export class RewardPaid__Params {
  _event: RewardPaid;

  constructor(event: RewardPaid) {
    this._event = event;
  }

  get _user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _rewardsToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _reward(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Staked extends ethereum.Event {
  get params(): Staked__Params {
    return new Staked__Params(this);
  }
}

export class Staked__Params {
  _event: Staked;

  constructor(event: Staked) {
    this._event = event;
  }

  get _user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _paidAmount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get _lockedAmount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get _boostedAmount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Withdrawn extends ethereum.Event {
  get params(): Withdrawn__Params {
    return new Withdrawn__Params(this);
  }
}

export class Withdrawn__Params {
  _event: Withdrawn;

  constructor(event: Withdrawn) {
    this._event = event;
  }

  get _user(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get _relocked(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class PenLockerV2__balancesResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class PenLockerV2__claimableRewardsResultUserRewardsStruct extends ethereum.Tuple {
  get token(): Address {
    return this[0].toAddress();
  }

  get amount(): BigInt {
    return this[1].toBigInt();
  }
}

export class PenLockerV2__epochsResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class PenLockerV2__lockedBalancesResultLockDataStruct extends ethereum.Tuple {
  get amount(): BigInt {
    return this[0].toBigInt();
  }

  get boosted(): BigInt {
    return this[1].toBigInt();
  }

  get unlockTime(): BigInt {
    return this[2].toBigInt();
  }
}

export class PenLockerV2__lockedBalancesResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;
  value3: Array<PenLockerV2__lockedBalancesResultLockDataStruct>;

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: BigInt,
    value3: Array<PenLockerV2__lockedBalancesResultLockDataStruct>
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromTupleArray(this.value3));
    return map;
  }
}

export class PenLockerV2__rewardDataResult {
  value0: boolean;
  value1: BigInt;
  value2: BigInt;
  value3: BigInt;
  value4: BigInt;
  value5: Address;

  constructor(
    value0: boolean,
    value1: BigInt,
    value2: BigInt,
    value3: BigInt,
    value4: BigInt,
    value5: Address
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    map.set("value5", ethereum.Value.fromAddress(this.value5));
    return map;
  }
}

export class PenLockerV2__userLocksResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class PenLockerV2 extends ethereum.SmartContract {
  static bind(address: Address): PenLockerV2 {
    return new PenLockerV2("PenLockerV2", address);
  }

  balanceAtEpochOf(_epoch: BigInt, _user: Address): BigInt {
    let result = super.call(
      "balanceAtEpochOf",
      "balanceAtEpochOf(uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_epoch),
        ethereum.Value.fromAddress(_user)
      ]
    );

    return result[0].toBigInt();
  }

  try_balanceAtEpochOf(
    _epoch: BigInt,
    _user: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "balanceAtEpochOf",
      "balanceAtEpochOf(uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(_epoch),
        ethereum.Value.fromAddress(_user)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balanceOf(_user: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(_user)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(_user: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(_user)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balances(param0: Address): PenLockerV2__balancesResult {
    let result = super.call(
      "balances",
      "balances(address):(uint112,uint112,uint32)",
      [ethereum.Value.fromAddress(param0)]
    );

    return new PenLockerV2__balancesResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_balances(
    param0: Address
  ): ethereum.CallResult<PenLockerV2__balancesResult> {
    let result = super.tryCall(
      "balances",
      "balances(address):(uint112,uint112,uint32)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new PenLockerV2__balancesResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  boostPayment(): Address {
    let result = super.call("boostPayment", "boostPayment():(address)", []);

    return result[0].toAddress();
  }

  try_boostPayment(): ethereum.CallResult<Address> {
    let result = super.tryCall("boostPayment", "boostPayment():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  boostRate(): BigInt {
    let result = super.call("boostRate", "boostRate():(uint256)", []);

    return result[0].toBigInt();
  }

  try_boostRate(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("boostRate", "boostRate():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  boostedSupply(): BigInt {
    let result = super.call("boostedSupply", "boostedSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_boostedSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "boostedSupply",
      "boostedSupply():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  claimableRewards(
    _account: Address
  ): Array<PenLockerV2__claimableRewardsResultUserRewardsStruct> {
    let result = super.call(
      "claimableRewards",
      "claimableRewards(address):((address,uint256)[])",
      [ethereum.Value.fromAddress(_account)]
    );

    return result[0].toTupleArray<
      PenLockerV2__claimableRewardsResultUserRewardsStruct
    >();
  }

  try_claimableRewards(
    _account: Address
  ): ethereum.CallResult<
    Array<PenLockerV2__claimableRewardsResultUserRewardsStruct>
  > {
    let result = super.tryCall(
      "claimableRewards",
      "claimableRewards(address):((address,uint256)[])",
      [ethereum.Value.fromAddress(_account)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<
        PenLockerV2__claimableRewardsResultUserRewardsStruct
      >()
    );
  }

  decimals(): i32 {
    let result = super.call("decimals", "decimals():(uint8)", []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    let result = super.tryCall("decimals", "decimals():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  denominator(): BigInt {
    let result = super.call("denominator", "denominator():(uint256)", []);

    return result[0].toBigInt();
  }

  try_denominator(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("denominator", "denominator():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  epochCount(): BigInt {
    let result = super.call("epochCount", "epochCount():(uint256)", []);

    return result[0].toBigInt();
  }

  try_epochCount(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("epochCount", "epochCount():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  epochs(param0: BigInt): PenLockerV2__epochsResult {
    let result = super.call("epochs", "epochs(uint256):(uint224,uint32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return new PenLockerV2__epochsResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_epochs(param0: BigInt): ethereum.CallResult<PenLockerV2__epochsResult> {
    let result = super.tryCall("epochs", "epochs(uint256):(uint224,uint32)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new PenLockerV2__epochsResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  findEpochId(_time: BigInt): BigInt {
    let result = super.call("findEpochId", "findEpochId(uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(_time)
    ]);

    return result[0].toBigInt();
  }

  try_findEpochId(_time: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "findEpochId",
      "findEpochId(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(_time)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getRewardForDuration(_rewardsToken: Address): BigInt {
    let result = super.call(
      "getRewardForDuration",
      "getRewardForDuration(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );

    return result[0].toBigInt();
  }

  try_getRewardForDuration(
    _rewardsToken: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getRewardForDuration",
      "getRewardForDuration(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  governanceAddress(): Address {
    let result = super.call(
      "governanceAddress",
      "governanceAddress():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_governanceAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "governanceAddress",
      "governanceAddress():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  governanceIsKilled(): boolean {
    let result = super.call(
      "governanceIsKilled",
      "governanceIsKilled():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_governanceIsKilled(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "governanceIsKilled",
      "governanceIsKilled():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isShutdown(): boolean {
    let result = super.call("isShutdown", "isShutdown():(bool)", []);

    return result[0].toBoolean();
  }

  try_isShutdown(): ethereum.CallResult<boolean> {
    let result = super.tryCall("isShutdown", "isShutdown():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  kickRewardEpochDelay(): BigInt {
    let result = super.call(
      "kickRewardEpochDelay",
      "kickRewardEpochDelay():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_kickRewardEpochDelay(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "kickRewardEpochDelay",
      "kickRewardEpochDelay():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  kickRewardPerEpoch(): BigInt {
    let result = super.call(
      "kickRewardPerEpoch",
      "kickRewardPerEpoch():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_kickRewardPerEpoch(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "kickRewardPerEpoch",
      "kickRewardPerEpoch():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lastTimeRewardApplicable(_rewardsToken: Address): BigInt {
    let result = super.call(
      "lastTimeRewardApplicable",
      "lastTimeRewardApplicable(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );

    return result[0].toBigInt();
  }

  try_lastTimeRewardApplicable(
    _rewardsToken: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lastTimeRewardApplicable",
      "lastTimeRewardApplicable(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockDuration(): BigInt {
    let result = super.call("lockDuration", "lockDuration():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lockDuration(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("lockDuration", "lockDuration():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockedBalanceOf(_user: Address): BigInt {
    let result = super.call(
      "lockedBalanceOf",
      "lockedBalanceOf(address):(uint256)",
      [ethereum.Value.fromAddress(_user)]
    );

    return result[0].toBigInt();
  }

  try_lockedBalanceOf(_user: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lockedBalanceOf",
      "lockedBalanceOf(address):(uint256)",
      [ethereum.Value.fromAddress(_user)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  lockedBalances(_user: Address): PenLockerV2__lockedBalancesResult {
    let result = super.call(
      "lockedBalances",
      "lockedBalances(address):(uint256,uint256,uint256,(uint112,uint112,uint32)[])",
      [ethereum.Value.fromAddress(_user)]
    );

    return new PenLockerV2__lockedBalancesResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toTupleArray<PenLockerV2__lockedBalancesResultLockDataStruct>()
    );
  }

  try_lockedBalances(
    _user: Address
  ): ethereum.CallResult<PenLockerV2__lockedBalancesResult> {
    let result = super.tryCall(
      "lockedBalances",
      "lockedBalances(address):(uint256,uint256,uint256,(uint112,uint112,uint32)[])",
      [ethereum.Value.fromAddress(_user)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new PenLockerV2__lockedBalancesResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toTupleArray<PenLockerV2__lockedBalancesResultLockDataStruct>()
      )
    );
  }

  lockedSupply(): BigInt {
    let result = super.call("lockedSupply", "lockedSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_lockedSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("lockedSupply", "lockedSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maximumBoostPayment(): BigInt {
    let result = super.call(
      "maximumBoostPayment",
      "maximumBoostPayment():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_maximumBoostPayment(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "maximumBoostPayment",
      "maximumBoostPayment():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  name(): string {
    let result = super.call("name", "name():(string)", []);

    return result[0].toString();
  }

  try_name(): ethereum.CallResult<string> {
    let result = super.tryCall("name", "name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  nextBoostRate(): BigInt {
    let result = super.call("nextBoostRate", "nextBoostRate():(uint256)", []);

    return result[0].toBigInt();
  }

  try_nextBoostRate(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "nextBoostRate",
      "nextBoostRate():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  nextMaximumBoostPayment(): BigInt {
    let result = super.call(
      "nextMaximumBoostPayment",
      "nextMaximumBoostPayment():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_nextMaximumBoostPayment(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "nextMaximumBoostPayment",
      "nextMaximumBoostPayment():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  operator(param0: Address): boolean {
    let result = super.call("operator", "operator(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBoolean();
  }

  try_operator(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("operator", "operator(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  proxyStorageInitialized(): boolean {
    let result = super.call(
      "proxyStorageInitialized",
      "proxyStorageInitialized():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_proxyStorageInitialized(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "proxyStorageInitialized",
      "proxyStorageInitialized():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  rewardData(param0: Address): PenLockerV2__rewardDataResult {
    let result = super.call(
      "rewardData",
      "rewardData(address):(bool,uint40,uint208,uint40,uint208,address)",
      [ethereum.Value.fromAddress(param0)]
    );

    return new PenLockerV2__rewardDataResult(
      result[0].toBoolean(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBigInt(),
      result[4].toBigInt(),
      result[5].toAddress()
    );
  }

  try_rewardData(
    param0: Address
  ): ethereum.CallResult<PenLockerV2__rewardDataResult> {
    let result = super.tryCall(
      "rewardData",
      "rewardData(address):(bool,uint40,uint208,uint40,uint208,address)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new PenLockerV2__rewardDataResult(
        value[0].toBoolean(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBigInt(),
        value[4].toBigInt(),
        value[5].toAddress()
      )
    );
  }

  rewardPerToken(_rewardsToken: Address): BigInt {
    let result = super.call(
      "rewardPerToken",
      "rewardPerToken(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );

    return result[0].toBigInt();
  }

  try_rewardPerToken(_rewardsToken: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "rewardPerToken",
      "rewardPerToken(address):(uint256)",
      [ethereum.Value.fromAddress(_rewardsToken)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardTokens(param0: BigInt): Address {
    let result = super.call("rewardTokens", "rewardTokens(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toAddress();
  }

  try_rewardTokens(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "rewardTokens",
      "rewardTokens(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  rewardTokensLength(): BigInt {
    let result = super.call(
      "rewardTokensLength",
      "rewardTokensLength():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_rewardTokensLength(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "rewardTokensLength",
      "rewardTokensLength():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardWeightOf(_user: Address): BigInt {
    let result = super.call(
      "rewardWeightOf",
      "rewardWeightOf(address):(uint256)",
      [ethereum.Value.fromAddress(_user)]
    );

    return result[0].toBigInt();
  }

  try_rewardWeightOf(_user: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "rewardWeightOf",
      "rewardWeightOf(address):(uint256)",
      [ethereum.Value.fromAddress(_user)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewards(param0: Address, param1: Address): BigInt {
    let result = super.call("rewards", "rewards(address,address):(uint256)", [
      ethereum.Value.fromAddress(param0),
      ethereum.Value.fromAddress(param1)
    ]);

    return result[0].toBigInt();
  }

  try_rewards(param0: Address, param1: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "rewards",
      "rewards(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rewardsDuration(): BigInt {
    let result = super.call(
      "rewardsDuration",
      "rewardsDuration():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_rewardsDuration(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "rewardsDuration",
      "rewardsDuration():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  stakingToken(): Address {
    let result = super.call("stakingToken", "stakingToken():(address)", []);

    return result[0].toAddress();
  }

  try_stakingToken(): ethereum.CallResult<Address> {
    let result = super.tryCall("stakingToken", "stakingToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  symbol(): string {
    let result = super.call("symbol", "symbol():(string)", []);

    return result[0].toString();
  }

  try_symbol(): ethereum.CallResult<string> {
    let result = super.tryCall("symbol", "symbol():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  totalSupply(): BigInt {
    let result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalSupplyAtEpoch(_epoch: BigInt): BigInt {
    let result = super.call(
      "totalSupplyAtEpoch",
      "totalSupplyAtEpoch(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(_epoch)]
    );

    return result[0].toBigInt();
  }

  try_totalSupplyAtEpoch(_epoch: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalSupplyAtEpoch",
      "totalSupplyAtEpoch(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(_epoch)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  userLocks(param0: Address, param1: BigInt): PenLockerV2__userLocksResult {
    let result = super.call(
      "userLocks",
      "userLocks(address,uint256):(uint112,uint112,uint32)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return new PenLockerV2__userLocksResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_userLocks(
    param0: Address,
    param1: BigInt
  ): ethereum.CallResult<PenLockerV2__userLocksResult> {
    let result = super.tryCall(
      "userLocks",
      "userLocks(address,uint256):(uint112,uint112,uint32)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new PenLockerV2__userLocksResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  userRewardPerTokenPaid(param0: Address, param1: Address): BigInt {
    let result = super.call(
      "userRewardPerTokenPaid",
      "userRewardPerTokenPaid(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBigInt();
  }

  try_userRewardPerTokenPaid(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "userRewardPerTokenPaid",
      "userRewardPerTokenPaid(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  version(): BigInt {
    let result = super.call("version", "version():(uint256)", []);

    return result[0].toBigInt();
  }

  try_version(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("version", "version():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class AddRewardCall extends ethereum.Call {
  get inputs(): AddRewardCall__Inputs {
    return new AddRewardCall__Inputs(this);
  }

  get outputs(): AddRewardCall__Outputs {
    return new AddRewardCall__Outputs(this);
  }
}

export class AddRewardCall__Inputs {
  _call: AddRewardCall;

  constructor(call: AddRewardCall) {
    this._call = call;
  }

  get _rewardsToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _distributor(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get duration(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class AddRewardCall__Outputs {
  _call: AddRewardCall;

  constructor(call: AddRewardCall) {
    this._call = call;
  }
}

export class AddReward1Call extends ethereum.Call {
  get inputs(): AddReward1Call__Inputs {
    return new AddReward1Call__Inputs(this);
  }

  get outputs(): AddReward1Call__Outputs {
    return new AddReward1Call__Outputs(this);
  }
}

export class AddReward1Call__Inputs {
  _call: AddReward1Call;

  constructor(call: AddReward1Call) {
    this._call = call;
  }

  get _rewardsToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _distributor(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _useBoost(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class AddReward1Call__Outputs {
  _call: AddReward1Call;

  constructor(call: AddReward1Call) {
    this._call = call;
  }
}

export class CheckpointEpochCall extends ethereum.Call {
  get inputs(): CheckpointEpochCall__Inputs {
    return new CheckpointEpochCall__Inputs(this);
  }

  get outputs(): CheckpointEpochCall__Outputs {
    return new CheckpointEpochCall__Outputs(this);
  }
}

export class CheckpointEpochCall__Inputs {
  _call: CheckpointEpochCall;

  constructor(call: CheckpointEpochCall) {
    this._call = call;
  }
}

export class CheckpointEpochCall__Outputs {
  _call: CheckpointEpochCall;

  constructor(call: CheckpointEpochCall) {
    this._call = call;
  }
}

export class GetRewardCall extends ethereum.Call {
  get inputs(): GetRewardCall__Inputs {
    return new GetRewardCall__Inputs(this);
  }

  get outputs(): GetRewardCall__Outputs {
    return new GetRewardCall__Outputs(this);
  }
}

export class GetRewardCall__Inputs {
  _call: GetRewardCall;

  constructor(call: GetRewardCall) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _rewardTokens(): Array<Address> {
    return this._call.inputValues[1].value.toAddressArray();
  }
}

export class GetRewardCall__Outputs {
  _call: GetRewardCall;

  constructor(call: GetRewardCall) {
    this._call = call;
  }
}

export class GetReward1Call extends ethereum.Call {
  get inputs(): GetReward1Call__Inputs {
    return new GetReward1Call__Inputs(this);
  }

  get outputs(): GetReward1Call__Outputs {
    return new GetReward1Call__Outputs(this);
  }
}

export class GetReward1Call__Inputs {
  _call: GetReward1Call;

  constructor(call: GetReward1Call) {
    this._call = call;
  }
}

export class GetReward1Call__Outputs {
  _call: GetReward1Call;

  constructor(call: GetReward1Call) {
    this._call = call;
  }
}

export class GetReward2Call extends ethereum.Call {
  get inputs(): GetReward2Call__Inputs {
    return new GetReward2Call__Inputs(this);
  }

  get outputs(): GetReward2Call__Outputs {
    return new GetReward2Call__Outputs(this);
  }
}

export class GetReward2Call__Inputs {
  _call: GetReward2Call;

  constructor(call: GetReward2Call) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _rewardsToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class GetReward2Call__Outputs {
  _call: GetReward2Call;

  constructor(call: GetReward2Call) {
    this._call = call;
  }
}

export class GetReward3Call extends ethereum.Call {
  get inputs(): GetReward3Call__Inputs {
    return new GetReward3Call__Inputs(this);
  }

  get outputs(): GetReward3Call__Outputs {
    return new GetReward3Call__Outputs(this);
  }
}

export class GetReward3Call__Inputs {
  _call: GetReward3Call;

  constructor(call: GetReward3Call) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class GetReward3Call__Outputs {
  _call: GetReward3Call;

  constructor(call: GetReward3Call) {
    this._call = call;
  }
}

export class InitializeProxyStorageCall extends ethereum.Call {
  get inputs(): InitializeProxyStorageCall__Inputs {
    return new InitializeProxyStorageCall__Inputs(this);
  }

  get outputs(): InitializeProxyStorageCall__Outputs {
    return new InitializeProxyStorageCall__Outputs(this);
  }
}

export class InitializeProxyStorageCall__Inputs {
  _call: InitializeProxyStorageCall;

  constructor(call: InitializeProxyStorageCall) {
    this._call = call;
  }

  get _rewardsDistributor(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _pen(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class InitializeProxyStorageCall__Outputs {
  _call: InitializeProxyStorageCall;

  constructor(call: InitializeProxyStorageCall) {
    this._call = call;
  }
}

export class KickExpiredLocksCall extends ethereum.Call {
  get inputs(): KickExpiredLocksCall__Inputs {
    return new KickExpiredLocksCall__Inputs(this);
  }

  get outputs(): KickExpiredLocksCall__Outputs {
    return new KickExpiredLocksCall__Outputs(this);
  }
}

export class KickExpiredLocksCall__Inputs {
  _call: KickExpiredLocksCall;

  constructor(call: KickExpiredLocksCall) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class KickExpiredLocksCall__Outputs {
  _call: KickExpiredLocksCall;

  constructor(call: KickExpiredLocksCall) {
    this._call = call;
  }
}

export class KillGovernanceCall extends ethereum.Call {
  get inputs(): KillGovernanceCall__Inputs {
    return new KillGovernanceCall__Inputs(this);
  }

  get outputs(): KillGovernanceCall__Outputs {
    return new KillGovernanceCall__Outputs(this);
  }
}

export class KillGovernanceCall__Inputs {
  _call: KillGovernanceCall;

  constructor(call: KillGovernanceCall) {
    this._call = call;
  }
}

export class KillGovernanceCall__Outputs {
  _call: KillGovernanceCall;

  constructor(call: KillGovernanceCall) {
    this._call = call;
  }
}

export class LockCall extends ethereum.Call {
  get inputs(): LockCall__Inputs {
    return new LockCall__Inputs(this);
  }

  get outputs(): LockCall__Outputs {
    return new LockCall__Outputs(this);
  }
}

export class LockCall__Inputs {
  _call: LockCall;

  constructor(call: LockCall) {
    this._call = call;
  }

  get _account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _spendRatio(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class LockCall__Outputs {
  _call: LockCall;

  constructor(call: LockCall) {
    this._call = call;
  }
}

export class NotifyRewardAmountCall extends ethereum.Call {
  get inputs(): NotifyRewardAmountCall__Inputs {
    return new NotifyRewardAmountCall__Inputs(this);
  }

  get outputs(): NotifyRewardAmountCall__Outputs {
    return new NotifyRewardAmountCall__Outputs(this);
  }
}

export class NotifyRewardAmountCall__Inputs {
  _call: NotifyRewardAmountCall;

  constructor(call: NotifyRewardAmountCall) {
    this._call = call;
  }

  get _rewardsToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _reward(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class NotifyRewardAmountCall__Outputs {
  _call: NotifyRewardAmountCall;

  constructor(call: NotifyRewardAmountCall) {
    this._call = call;
  }
}

export class ProcessExpiredLocksCall extends ethereum.Call {
  get inputs(): ProcessExpiredLocksCall__Inputs {
    return new ProcessExpiredLocksCall__Inputs(this);
  }

  get outputs(): ProcessExpiredLocksCall__Outputs {
    return new ProcessExpiredLocksCall__Outputs(this);
  }
}

export class ProcessExpiredLocksCall__Inputs {
  _call: ProcessExpiredLocksCall;

  constructor(call: ProcessExpiredLocksCall) {
    this._call = call;
  }

  get _relock(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class ProcessExpiredLocksCall__Outputs {
  _call: ProcessExpiredLocksCall;

  constructor(call: ProcessExpiredLocksCall) {
    this._call = call;
  }
}

export class ProcessExpiredLocks1Call extends ethereum.Call {
  get inputs(): ProcessExpiredLocks1Call__Inputs {
    return new ProcessExpiredLocks1Call__Inputs(this);
  }

  get outputs(): ProcessExpiredLocks1Call__Outputs {
    return new ProcessExpiredLocks1Call__Outputs(this);
  }
}

export class ProcessExpiredLocks1Call__Inputs {
  _call: ProcessExpiredLocks1Call;

  constructor(call: ProcessExpiredLocks1Call) {
    this._call = call;
  }

  get _relock(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }

  get _spendRatio(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _withdrawTo(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class ProcessExpiredLocks1Call__Outputs {
  _call: ProcessExpiredLocks1Call;

  constructor(call: ProcessExpiredLocks1Call) {
    this._call = call;
  }
}

export class RecoverERC20Call extends ethereum.Call {
  get inputs(): RecoverERC20Call__Inputs {
    return new RecoverERC20Call__Inputs(this);
  }

  get outputs(): RecoverERC20Call__Outputs {
    return new RecoverERC20Call__Outputs(this);
  }
}

export class RecoverERC20Call__Inputs {
  _call: RecoverERC20Call;

  constructor(call: RecoverERC20Call) {
    this._call = call;
  }

  get _tokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _tokenAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RecoverERC20Call__Outputs {
  _call: RecoverERC20Call;

  constructor(call: RecoverERC20Call) {
    this._call = call;
  }
}

export class SetBoostCall extends ethereum.Call {
  get inputs(): SetBoostCall__Inputs {
    return new SetBoostCall__Inputs(this);
  }

  get outputs(): SetBoostCall__Outputs {
    return new SetBoostCall__Outputs(this);
  }
}

export class SetBoostCall__Inputs {
  _call: SetBoostCall;

  constructor(call: SetBoostCall) {
    this._call = call;
  }

  get _max(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _rate(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _receivingAddress(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class SetBoostCall__Outputs {
  _call: SetBoostCall;

  constructor(call: SetBoostCall) {
    this._call = call;
  }
}

export class SetGovernanceAddressCall extends ethereum.Call {
  get inputs(): SetGovernanceAddressCall__Inputs {
    return new SetGovernanceAddressCall__Inputs(this);
  }

  get outputs(): SetGovernanceAddressCall__Outputs {
    return new SetGovernanceAddressCall__Outputs(this);
  }
}

export class SetGovernanceAddressCall__Inputs {
  _call: SetGovernanceAddressCall;

  constructor(call: SetGovernanceAddressCall) {
    this._call = call;
  }

  get _governanceAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetGovernanceAddressCall__Outputs {
  _call: SetGovernanceAddressCall;

  constructor(call: SetGovernanceAddressCall) {
    this._call = call;
  }
}

export class SetKickIncentiveCall extends ethereum.Call {
  get inputs(): SetKickIncentiveCall__Inputs {
    return new SetKickIncentiveCall__Inputs(this);
  }

  get outputs(): SetKickIncentiveCall__Outputs {
    return new SetKickIncentiveCall__Outputs(this);
  }
}

export class SetKickIncentiveCall__Inputs {
  _call: SetKickIncentiveCall;

  constructor(call: SetKickIncentiveCall) {
    this._call = call;
  }

  get _rate(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _delay(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetKickIncentiveCall__Outputs {
  _call: SetKickIncentiveCall;

  constructor(call: SetKickIncentiveCall) {
    this._call = call;
  }
}

export class SetOperatorCall extends ethereum.Call {
  get inputs(): SetOperatorCall__Inputs {
    return new SetOperatorCall__Inputs(this);
  }

  get outputs(): SetOperatorCall__Outputs {
    return new SetOperatorCall__Outputs(this);
  }
}

export class SetOperatorCall__Inputs {
  _call: SetOperatorCall;

  constructor(call: SetOperatorCall) {
    this._call = call;
  }

  get candidate(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get status(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetOperatorCall__Outputs {
  _call: SetOperatorCall;

  constructor(call: SetOperatorCall) {
    this._call = call;
  }
}

export class SetVotingSnapshotCall extends ethereum.Call {
  get inputs(): SetVotingSnapshotCall__Inputs {
    return new SetVotingSnapshotCall__Inputs(this);
  }

  get outputs(): SetVotingSnapshotCall__Outputs {
    return new SetVotingSnapshotCall__Outputs(this);
  }
}

export class SetVotingSnapshotCall__Inputs {
  _call: SetVotingSnapshotCall;

  constructor(call: SetVotingSnapshotCall) {
    this._call = call;
  }

  get _votingSnapshot(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetVotingSnapshotCall__Outputs {
  _call: SetVotingSnapshotCall;

  constructor(call: SetVotingSnapshotCall) {
    this._call = call;
  }
}

export class ShutdownCall extends ethereum.Call {
  get inputs(): ShutdownCall__Inputs {
    return new ShutdownCall__Inputs(this);
  }

  get outputs(): ShutdownCall__Outputs {
    return new ShutdownCall__Outputs(this);
  }
}

export class ShutdownCall__Inputs {
  _call: ShutdownCall;

  constructor(call: ShutdownCall) {
    this._call = call;
  }
}

export class ShutdownCall__Outputs {
  _call: ShutdownCall;

  constructor(call: ShutdownCall) {
    this._call = call;
  }
}

export class UpdateRewardsCall extends ethereum.Call {
  get inputs(): UpdateRewardsCall__Inputs {
    return new UpdateRewardsCall__Inputs(this);
  }

  get outputs(): UpdateRewardsCall__Outputs {
    return new UpdateRewardsCall__Outputs(this);
  }
}

export class UpdateRewardsCall__Inputs {
  _call: UpdateRewardsCall;

  constructor(call: UpdateRewardsCall) {
    this._call = call;
  }
}

export class UpdateRewardsCall__Outputs {
  _call: UpdateRewardsCall;

  constructor(call: UpdateRewardsCall) {
    this._call = call;
  }
}

export class WithdrawExpiredLocksToCall extends ethereum.Call {
  get inputs(): WithdrawExpiredLocksToCall__Inputs {
    return new WithdrawExpiredLocksToCall__Inputs(this);
  }

  get outputs(): WithdrawExpiredLocksToCall__Outputs {
    return new WithdrawExpiredLocksToCall__Outputs(this);
  }
}

export class WithdrawExpiredLocksToCall__Inputs {
  _call: WithdrawExpiredLocksToCall;

  constructor(call: WithdrawExpiredLocksToCall) {
    this._call = call;
  }

  get _withdrawTo(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class WithdrawExpiredLocksToCall__Outputs {
  _call: WithdrawExpiredLocksToCall;

  constructor(call: WithdrawExpiredLocksToCall) {
    this._call = call;
  }
}
